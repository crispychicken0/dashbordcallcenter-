import json
import uuid
from datetime import datetime, timedelta
from enum import Enum
from typing import Dict, List, Optional, Tuple
import random
import math

# ================= ENUMS =================
class OrderStatus(Enum):
    RECEIVED = "received"
    IN_KITCHEN = "in_kitchen"
    READY = "ready"
    OUT_FOR_DELIVERY = "out_for_delivery"
    DELIVERED = "delivered"

class OrderChannel(Enum):
    PHONE = "phone"
    WEB = "web"
    APP = "app"
    AGGREGATOR = "aggregator"

class PaymentStatus(Enum):
    PENDING = "pending"
    PAID = "paid"
    FAILED = "failed"

class DriverStatus(Enum):
    AVAILABLE = "available"
    ON_DELIVERY = "on_delivery"
    OFFLINE = "offline"

class KitchenStatus(Enum):
    IDLE = "idle"
    PREPARING = "preparing"
    OVERLOADED = "overloaded"

# ================= MODELS =================
class MenuItem:
    def __init__(self, id: str, name: str, price: float, prep_time: int, ingredients: Dict[str, int]):
        self.id = id
        self.name = name
        self.price = price
        self.prep_time = prep_time  # in minutes
        self.ingredients = ingredients  # {ingredient_id: quantity}

class OrderItem:
    def __init__(self, menu_item: MenuItem, quantity: int):
        self.menu_item = menu_item
        self.quantity = quantity

class Order:
    def __init__(self, customer_id: str, items: List[OrderItem], channel: OrderChannel, 
                 delivery_address: Tuple[float, float], payment_status: PaymentStatus = PaymentStatus.PENDING):
        self.id = str(uuid.uuid4())
        self.customer_id = customer_id
        self.items = items
        self.channel = channel
        self.status = OrderStatus.RECEIVED
        self.payment_status = payment_status
        self.delivery_address = delivery_address
        self.created_at = datetime.now()
        self.outlet_id = None
        self.driver_id = None
        self.estimated_delivery = None
        self.total_amount = sum(item.menu_item.price * item.quantity for item in items)
        self.prep_start_time = None
        self.ready_time = None

class Outlet:
    def __init__(self, id: str, name: str, location: Tuple[float, float], capacity: int):
        self.id = id
        self.name = name
        self.location = location  # (latitude, longitude)
        self.capacity = capacity
        self.current_orders = []
        self.inventory = {}
        self.staff = {}
        self.kitchen_status = KitchenStatus.IDLE

class Driver:
    def __init__(self, id: str, name: str, vehicle_type: str, location: Tuple[float, float]):
        self.id = id
        self.name = name
        self.vehicle_type = vehicle_type
        self.location = location
        self.status = DriverStatus.AVAILABLE
        self.current_order = None
        self.rating = 4.5
        self.orders_completed = 0

class InventoryItem:
    def __init__(self, item_id: str, name: str, quantity: int, unit: str, reorder_threshold: int):
        self.item_id = item_id
        self.name = name
        self.quantity = quantity
        self.unit = unit
        self.reorder_threshold = reorder_threshold

class Staff:
    def __init__(self, id: str, name: str, role: str, hourly_rate: float):
        self.id = id
        self.name = name
        self.role = role  # "chef", "manager", "cashier"
        self.hourly_rate = hourly_rate
        self.current_order = None
        self.shift_start = None
        self.shift_end = None

# ================= CORE SYSTEM =================
class RestaurantDeliverySystem:
    def __init__(self):
        self.orders: Dict[str, Order] = {}
        self.outlets: Dict[str, Outlet] = {}
        self.drivers: Dict[str, Driver] = {}
        self.menu_items: Dict[str, MenuItem] = {}
        self.inventory_items: Dict[str, InventoryItem] = {}
        self.staff: Dict[str, Staff] = {}
        self.order_history = []
        self.delivery_partners = {}
        
    # ================= INITIALIZATION =================
    def initialize_system(self):
        # Add menu items
        self.menu_items["pizza_margherita"] = MenuItem(
            "pizza_margherita", "Pizza Margherita", 12.99, 15, 
            {"flour": 1, "cheese": 150, "tomato": 100}
        )
        self.menu_items["burger"] = MenuItem(
            "burger", "Classic Burger", 8.99, 10,
            {"bread": 1, "beef": 150, "lettuce": 50, "tomato": 30}
        )
        self.menu_items["pasta_carbonara"] = MenuItem(
            "pasta_carbonara", "Pasta Carbonara", 10.99, 12,
            {"pasta": 200, "bacon": 100, "cream": 100, "cheese": 50}
        )
        self.menu_items["salad"] = MenuItem(
            "salad", "Garden Salad", 7.99, 8,
            {"lettuce": 100, "tomato": 80, "cucumber": 60, "dressing": 30}
        )
        
        # Add inventory items
        self.inventory_items["flour"] = InventoryItem("flour", "Flour", 50, "kg", 10)
        self.inventory_items["cheese"] = InventoryItem("cheese", "Cheese", 30, "kg", 5)
        self.inventory_items["tomato"] = InventoryItem("tomato", "Tomato", 40, "kg", 8)
        self.inventory_items["bread"] = InventoryItem("bread", "Bread", 30, "loaves", 5)
        self.inventory_items["beef"] = InventoryItem("beef", "Ground Beef", 25, "kg", 8)
        self.inventory_items["lettuce"] = InventoryItem("lettuce", "Lettuce", 20, "kg", 5)
        self.inventory_items["cucumber"] = InventoryItem("cucumber", "Cucumber", 15, "kg", 4)
        self.inventory_items["dressing"] = InventoryItem("dressing", "Salad Dressing", 10, "L", 3)
        self.inventory_items["pasta"] = InventoryItem("pasta", "Pasta", 20, "kg", 6)
        self.inventory_items["bacon"] = InventoryItem("bacon", "Bacon", 15, "kg", 4)
        self.inventory_items["cream"] = InventoryItem("cream", "Cream", 12, "L", 3)
        
        # Add outlets
        self.outlets["downtown"] = Outlet("downtown", "Downtown Branch", (40.7128, -74.0060), 10)
        self.outlets["westside"] = Outlet("westside", "Westside Branch", (40.7489, -73.9680), 8)
        self.outlets["uptown"] = Outlet("uptown", "Uptown Branch", (40.7831, -73.9712), 12)
        
        # Add drivers
        self.drivers["driver1"] = Driver("driver1", "John Smith", "motorcycle", (40.7128, -74.0060))
        self.drivers["driver2"] = Driver("driver2", "Sarah Johnson", "car", (40.7489, -73.9680))
        self.drivers["driver3"] = Driver("driver3", "Mike Brown", "van", (40.7831, -73.9712))
        self.drivers["driver4"] = Driver("driver4", "Emily Davis", "motorcycle", (40.7128, -74.0060))
        self.drivers["driver5"] = Driver("driver5", "David Wilson", "car", (40.7489, -73.9680))
        
        # Add staff
        self.staff["chef1"] = Staff("chef1", "Chef Marco", "chef", 25.0)
        self.staff["chef2"] = Staff("chef2", "Chef Luis", "chef", 22.0)
        self.staff["chef3"] = Staff("chef3", "Chef Sofia", "chef", 23.0)
        self.staff["manager1"] = Staff("manager1", "Manager Anna", "manager", 30.0)
        self.staff["cashier1"] = Staff("cashier1", "Cashier Tom", "cashier", 15.0)
        
        # Assign staff to outlets
        self.outlets["downtown"].staff = {"chef1": self.staff["chef1"], "manager1": self.staff["manager1"]}
        self.outlets["westside"].staff = {"chef2": self.staff["chef2"], "cashier1": self.staff["cashier1"]}
        self.outlets["uptown"].staff = {"chef3": self.staff["chef3"]}
        
        # Initialize inventory in outlets
        for outlet in self.outlets.values():
            for item_id, item in self.inventory_items.items():
                outlet.inventory[item_id] = InventoryItem(
                    item_id, item.name, item.quantity, item.unit, item.reorder_threshold
                )
        
        print("Restaurant Delivery System initialized successfully!")
    
    # ================= ORDER MANAGEMENT =================
    def create_order(self, customer_id: str, item_ids: List[str], quantities: List[int], 
                     channel: OrderChannel, delivery_address: Tuple[float, float]) -> Optional[Order]:
        # Validate menu items
        if not all(item_id in self.menu_items for item_id in item_ids):
            print("Error: Invalid menu item ID")
            return None
            
        # Create order items
        order_items = []
        for i, item_id in enumerate(item_ids):
            order_items.append(OrderItem(self.menu_items[item_id], quantities[i]))
            
        # Create new order
        order = Order(customer_id, order_items, channel, delivery_address)
        
        # Distribute to outlet
        outlet = self._distribute_order_to_outlet(order)
        if not outlet:
            print("Error: No available outlets")
            return None
            
        order.outlet_id = outlet.id
        outlet.current_orders.append(order.id)
        self.orders[order.id] = order
        
        # Update inventory
        self._update_inventory(order)
        
        # Calculate estimated delivery time
        self._calculate_delivery_time(order)
        
        # Assign to kitchen
        self._assign_to_kitchen(order)
        
        print(f"Order {order.id} created from {channel.value} channel")
        return order
    
    def _distribute_order_to_outlet(self, order: Order) -> Optional[Outlet]:
        # Find nearest outlet with capacity
        min_distance = float('inf')
        selected_outlet = None
        
        for outlet in self.outlets.values():
            # Calculate distance using Haversine formula
            distance = self._haversine_distance(outlet.location, order.delivery_address)
            load_factor = len(outlet.current_orders) / outlet.capacity
            
            if load_factor < 1.0 and distance < min_distance:
                min_distance = distance
                selected_outlet = outlet
                
        return selected_outlet
    
    def _haversine_distance(self, loc1: Tuple[float, float], loc2: Tuple[float, float]) -> float:
        # Calculate distance between two lat/lon points in km
        lat1, lon1 = loc1
        lat2, lon2 = loc2
        
        R = 6371  # Earth radius in km
        dLat = math.radians(lat2 - lat1)
        dLon = math.radians(lon2 - lon1)
        a = math.sin(dLat/2) * math.sin(dLat/2) + \
            math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * \
            math.sin(dLon/2) * math.sin(dLon/2)
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        return R * c
    
    def _update_inventory(self, order: Order):
        outlet = self.outlets[order.outlet_id]
        
        for order_item in order.items:
            for ingredient_id, required_qty in order_item.menu_item.ingredients.items():
                if ingredient_id in outlet.inventory:
                    outlet.inventory[ingredient_id].quantity -= required_qty * order_item.quantity
                    
                    # Check if reorder needed
                    if outlet.inventory[ingredient_id].quantity < outlet.inventory[ingredient_id].reorder_threshold:
                        print(f"Reorder needed for {outlet.inventory[ingredient_id].name} at {outlet.name}")
    
    def _calculate_delivery_time(self, order: Order):
        outlet = self.outlets[order.outlet_id]
        
        # Calculate preparation time
        prep_time = sum(item.menu_item.prep_time * item.quantity for item in order.items)
        
        # Find nearest available driver
        available_drivers = [d for d in self.drivers.values() if d.status == DriverStatus.AVAILABLE]
        if not available_drivers:
            # Estimate based on average driver time
            driver_time = 30
        else:
            # Find nearest driver
            nearest_driver = min(available_drivers, 
                                key=lambda d: self._haversine_distance(d.location, outlet.location))
            driver_time = self._haversine_distance(nearest_driver.location, outlet.location) * 2  # 2 min/km
        
        # Add buffer time
        buffer = 10
        total_time = prep_time + driver_time + buffer
        
        order.estimated_delivery = datetime.now() + timedelta(minutes=total_time)
    
    def _assign_to_kitchen(self, order: Order):
        outlet = self.outlets[order.outlet_id]
        outlet.kitchen_status = KitchenStatus.PREPARING
        order.prep_start_time = datetime.now()
        order.status = OrderStatus.IN_KITCHEN
        
        # Assign chef to order
        available_chefs = [s for s in outlet.staff.values() if s.role == "chef" and s.current_order is None]
        if available_chefs:
            chef = random.choice(available_chefs)
            chef.current_order = order.id
            print(f"Order {order.id} assigned to chef {chef.name}")
        
        # Simulate preparation time
        prep_time = sum(item.menu_item.prep_time * item.quantity for item in order.items)
        
        # Schedule order to be ready
        from threading import Timer
        Timer(prep_time * 60, self._mark_order_ready, args=[order.id]).start()
    
    def _mark_order_ready(self, order_id: str):
        if order_id in self.orders:
            order = self.orders[order_id]
            order.status = OrderStatus.READY
            order.ready_time = datetime.now()
            
            outlet = self.outlets[order.outlet_id]
            outlet.kitchen_status = KitchenStatus.IDLE
            
            # Release chef
            for staff in outlet.staff.values():
                if staff.current_order == order_id:
                    staff.current_order = None
                    break
            
            print(f"Order {order_id} is ready for delivery")
            
            # Assign driver
            self._assign_driver(order_id)
    
    def _assign_driver(self, order_id: str):
        order = self.orders[order_id]
        outlet = self.outlets[order.outlet_id]
        
        # Find nearest available driver
        available_drivers = [d for d in self.drivers.values() if d.status == DriverStatus.AVAILABLE]
        if not available_drivers:
            print("No available drivers!")
            return
            
        # Find nearest driver
        nearest_driver = min(available_drivers, 
                            key=lambda d: self._haversine_distance(d.location, outlet.location))
        
        # Assign driver
        nearest_driver.current_order = order_id
        nearest_driver.status = DriverStatus.ON_DELIVERY
        order.driver_id = nearest_driver.id
        
        # Calculate delivery time
        delivery_time = self._haversine_distance(outlet.location, order.delivery_address) * 2
        
        # Schedule delivery completion
        from threading import Timer
        Timer(delivery_time * 60, self._complete_delivery, args=[order_id]).start()
        
        print(f"Driver {nearest_driver.name} assigned to order {order_id}")
    
    def _complete_delivery(self, order_id: str):
        if order_id in self.orders:
            order = self.orders[order_id]
            order.status = OrderStatus.DELIVERED
            
            # Release driver
            driver = self.drivers[order.driver_id]
            driver.status = DriverStatus.AVAILABLE
            driver.current_order = None
            driver.orders_completed += 1
            
            # Remove from outlet
            outlet = self.outlets[order.outlet_id]
            if order_id in outlet.current_orders:
                outlet.current_orders.remove(order_id)
            
            # Add to order history
            self.order_history.append(order)
            
            print(f"Order {order_id} delivered successfully")
    
    # ================= ORDER STATUS MANAGEMENT =================
    def update_order_status(self, order_id: str, status: OrderStatus):
        if order_id in self.orders:
            self.orders[order_id].status = status
            print(f"Order {order_id} status updated to {status.value}")
    
    def get_order_status(self, order_id: str) -> Optional[OrderStatus]:
        return self.orders.get(order_id, {}).status if order_id in self.orders else None
    
    def cancel_order(self, order_id: str):
        if order_id in self.orders:
            order = self.orders[order_id]
            
            # If order is in kitchen, release chef
            if order.status == OrderStatus.IN_KITCHEN:
                outlet = self.outlets[order.outlet_id]
                for staff in outlet.staff.values():
                    if staff.current_order == order_id:
                        staff.current_order = None
                        break
            
            # If driver is assigned, release driver
            if order.driver_id:
                driver = self.drivers[order.driver_id]
                driver.current_order = None
                driver.status = DriverStatus.AVAILABLE
            
            # Remove from outlet
            outlet = self.outlets[order.outlet_id]
            if order_id in outlet.current_orders:
                outlet.current_orders.remove(order_id)
            
            # Remove from system
            del self.orders[order_id]
            print(f"Order {order_id} cancelled successfully")
    
    # ================= REAL-TIME MONITORING =================
    def get_real_time_dashboard(self) -> Dict:
        return {
            "total_orders": len(self.orders),
            "active_orders": sum(1 for o in self.orders.values() if o.status in [OrderStatus.IN_KITCHEN, OrderStatus.READY]),
            "drivers_on_delivery": sum(1 for d in self.drivers.values() if d.status == DriverStatus.ON_DELIVERY),
            "outlet_load": {outlet.id: len(outlet.current_orders) for outlet in self.outlets.values()},
            "kitchen_status": {outlet.id: outlet.kitchen_status.value for outlet in self.outlets.values()},
            "inventory_levels": {outlet.id: {item.name: item.quantity for item in outlet.inventory.values()} 
                               for outlet in self.outlets.values()}
        }
    
    def get_driver_locations(self) -> Dict:
        return {driver_id: driver.location for driver_id, driver in self.drivers.items()}
    
    def get_order_details(self, order_id: str) -> Optional[Dict]:
        if order_id in self.orders:
            order = self.orders[order_id]
            return {
                "id": order.id,
                "status": order.status.value,
                "channel": order.channel.value,
                "total_amount": order.total_amount,
                "items": [{"name": item.menu_item.name, "quantity": item.quantity} for item in order.items],
                "delivery_address": order.delivery_address,
                "estimated_delivery": order.estimated_delivery.isoformat() if order.estimated_delivery else None,
                "driver": self.drivers[order.driver_id].name if order.driver_id else None
            }
        return None
    
    # ================= REPORTING =================
    def generate_sales_report(self, start_date: datetime, end_date: datetime) -> Dict:
        total_sales = 0
        orders_by_channel = {channel.value: 0 for channel in OrderChannel}
        orders_by_outlet = {outlet.id: 0 for outlet in self.outlets.values()}
        popular_items = {}
        
        for order in self.order_history:
            if start_date <= order.created_at <= end_date:
                total_sales += order.total_amount
                orders_by_channel[order.channel.value] += 1
                orders_by_outlet[order.outlet_id] += 1
                
                for item in order.items:
                    item_name = item.menu_item.name
                    popular_items[item_name] = popular_items.get(item_name, 0) + item.quantity
        
        return {
            "total_sales": total_sales,
            "order_count": len([o for o in self.order_history if start_date <= o.created_at <= end_date]),
            "orders_by_channel": orders_by_channel,
            "orders_by_outlet": orders_by_outlet,
            "popular_items": popular_items
        }
    
    def generate_driver_performance_report(self) -> Dict:
        driver_stats = {}
        for driver in self.drivers.values():
            driver_stats[driver.name] = {
                "orders_completed": driver.orders_completed,
                "rating": driver.rating,
                "status": driver.status.value
            }
        return driver_stats
    
    def generate_inventory_report(self) -> Dict:
        inventory_report = {}
        for outlet in self.outlets.values():
            low_stock = []
            for item in outlet.inventory.values():
                if item.quantity < item.reorder_threshold:
                    low_stock.append(item.name)
            
            inventory_report[outlet.name] = {
                "low_stock_items": low_stock,
                "total_items": len(outlet.inventory)
            }
        return inventory_report

# ================= DEMO =================
def run_demo():
    # Initialize system
    system = RestaurantDeliverySystem()
    system.initialize_system()
    
    print("\n" + "="*50)
    print("RESTAURANT DELIVERY SYSTEM DEMO")
    print("="*50 + "\n")
    
    # Create orders from different channels
    print("\n=== Creating Orders ===")
    order1 = system.create_order(
        customer_id="cust1",
        item_ids=["pizza_margherita", "burger"],
        quantities=[1, 2],
        channel=OrderChannel.WEB,
        delivery_address=(40.7580, -73.9855)
    )
    
    order2 = system.create_order(
        customer_id="cust2",
        item_ids=["pasta_carbonara"],
        quantities=[1],
        channel=OrderChannel.APP,
        delivery_address=(40.7489, -73.9680)
    )
    
    order3 = system.create_order(
        customer_id="cust3",
        item_ids=["salad", "pizza_margherita"],
        quantities=[2, 1],
        channel=OrderChannel.AGGREGATOR,
        delivery_address=(40.7831, -73.9712)
    )
    
    # Display real-time dashboard
    print("\n=== Real-Time Dashboard ===")
    dashboard = system.get_real_time_dashboard()
    print(json.dumps(dashboard, indent=2))
    
    # Display driver locations
    print("\n=== Driver Locations ===")
    driver_locations = system.get_driver_locations()
    print(json.dumps(driver_locations, indent=2))
    
    # Display order details
    print("\n=== Order Details ===")
    for order_id in [order1.id, order2.id, order3.id]:
        details = system.get_order_details(order_id)
        print(f"\nOrder {order_id}:")
        print(json.dumps(details, indent=2))
    
    # Simulate time passing (orders will be processed automatically)
    print("\n=== Processing Orders (Simulated Time) ===")
    print("Orders are being prepared and drivers assigned...")
    
    # Generate reports after some time
    import time
    time.sleep(5)  # Wait for orders to be processed
    
    print("\n=== Sales Report ===")
    sales_report = system.generate_sales_report(
        datetime.now() - timedelta(days=1), 
        datetime.now()
    )
    print(json.dumps(sales_report, indent=2))
    
    print("\n=== Driver Performance Report ===")
    driver_report = system.generate_driver_performance_report()
    print(json.dumps(driver_report, indent=2))
    
    print("\n=== Inventory Report ===")
    inventory_report = system.generate_inventory_report()
    print(json.dumps(inventory_report, indent=2))
    
    # Cancel an order
    print("\n=== Cancelling an Order ===")
    system.cancel_order(order2.id)
    
    # Final dashboard
    print("\n=== Final Dashboard ===")
    dashboard = system.get_real_time_dashboard()
    print(json.dumps(dashboard, indent=2))

if __name__ == "__main__":
    run_demo()
